# Life-OS Roadmap

PURPOSE:
Provide a clear, evolving path for building Life-OS
while maximizing learning signal, mastery, and transfer.

RULE:
This roadmap is directional, not fixed.
Reordering is allowed when learning value improves.

CHECKBOXES indicate:
- learning milestones
- not feature completeness
- not production readiness

GLOBAL ASSERTIONS:
- safety precedes capability
- observability precedes optimization
- explanation precedes automation
- trust is earned, not assumed

---

# PHASE_0: FOUNDATIONS & RESET

GOAL:
Establish shared language, constraints, and a learning-first posture.

FOCUS:
Shared vocabulary
Constraints and failure modes
Learning-first development posture

DELIVERABLES:
- [x] Life-OS intent & alignment locked
- [x] Sudolang conventions finalized
- [x] Teaching / cache-warm protocol defined
- [x] Learning vs product explicitly unified
- [x] Definition of “mastery” made explicit

SCAFFOLDING TOUCHED:
- Problem framing as a first-class activity
- Success defined before optimization
- Learning artifacts treated as system outputs

EXIT_CRITERIA:
You can explain:
- what Life-OS optimizes for
- why safety precedes capability
- why learning artifacts are first-class

---

# PHASE_1: LIFE-OS DNA — SEMANTIC GENOME

GOAL:
Define meaning, trust, and invariants independent of execution.

FOCUS:
Ontology
Authority
Invariants
Meaning lifecycle

DELIVERABLES:
- [x] Meaning vs storage separated
- [x] Trust levels defined (MEMORY → NOTE → ARTIFACT → DERIVED)
- [x] Invariants articulated in prose
- [x] Authority escalation rules identified
- [x] DNA/RNA/Expression mental model stabilized

SCAFFOLDING TOUCHED:
- Ground truth definitions (pre-model)
- Semantic stability independent of model choice
- Foundations for prompt correctness and refusal reasoning

EXIT_CRITERIA:
You can change meaning definitions
without touching execution logic.

---

# PHASE_2: LIFE-OS RNA — SAFE ACTION & GOVERNANCE

GOAL:
Define how meaning turns into action safely.

FOCUS:
Proposals
Validation
Planning
Execution
Re-validation
Commit

CORE ASSERTIONS:
- execution ≠ belief
- belief only occurs at commit
- silent corruption is the primary failure mode

DELIVERABLES:
- [x] Proposal intake contract
- [x] Validation contract
- [x] Planning contract
- [x] Execution contract
- [x] Re-validation contract
- [x] Commit contract
- [x] RNA pipeline spec
- [x] Weekly reflection paper-executed
- [x] Phase 2 fundamentals extracted

SCAFFOLDING TOUCHED:
- Prompt evaluation boundaries (validation vs execution)
- Refusal and constraint modeling
- Early agent boundaries (without agents)
- Model outputs treated as untrusted inputs

EXIT_CRITERIA:
You can explain:
- why execution ≠ belief
- why re-validation exists
- how silent corruption happens

---

# PHASE_3: RNA — CONCRETE CONTROL FLOW

STATUS: COMPLETE

GOAL:
Implement a minimal, correct execution kernel
that enforces RNA contracts end-to-end.

FOCUS:
Determinism
Stage isolation
Type safety
Runtime enforcement
Tooling portability

DELIVERABLES:
- [x] In-memory pipeline implementation (TypeScript)
- [x] Zod schemas for all stage artifacts
- [x] Stage-level invariant enforcement
- [x] Full audit trail wiring
- [x] One workflow fully runnable (weekly reflection)

SCAFFOLDING TOUCHED:
- System observability primitives
- Error classification and traceability
- Measurement points for latency, correctness, and cost (not optimized)

NON-GOALS:
- persistence (beyond minimal outbox shape)
- performance
- UI polish
- agent swarms

EXIT_CRITERIA:
You can trace intent → commit in code
and point to where every invariant is enforced.

---

# PHASE_3A: MINIMAL IMPLEMENTATION SCAFFOLDING

STATUS: COMPLETE

GOAL:
Make RNA concrete without adding business behavior.

FOCUS:
Types
Schemas
Shape correctness
Guard purity (pre-guards vs guards)
Deterministic artifacts (fingerprints)

DELIVERABLES:
- [x] TypeScript interfaces for all pipeline artifacts
- [x] Zod schemas enforcing contract boundaries
- [x] Explicit invariant checks at stage boundaries
- [x] Zero business logic beyond enforcement
- [x] Deterministic planning fingerprinting
- [x] Drift tests (runtime invariant not capturable by types)

LEARNING_SIGNAL:
Specs become executable shapes.
Safety becomes tangible.
Runtime guards reveal invariants types alone cannot enforce.
Tool boundaries become explicit and portable.

EXIT_CRITERIA:
You can build any stage confidently
because its contract is enforced by types + tests.

---

# PHASE_3A.1: SINGLE WORKFLOW RUNNABLE (WEEKLY REFLECTION)

STATUS: COMPLETE

GOAL:
Prove the whole RNA spine works end-to-end in-process.

FOCUS:
End-to-end determinism
Envelope auditability
Drift rejection
Commit gating vs apply

DELIVERABLES:
- [x] A single pipeline run reaches COMMIT deterministically
- [x] Envelope captures full audit trail for every stage
- [x] Commit produces approved effects without applying them
- [x] Revalidation blocks drift from becoming committable
- [x] Execution produces only untrusted outputs (PROVISIONAL)

RULE:
Make it runnable before making it powerful.

EXIT_CRITERIA:
You can run weekly reflection locally and inspect:
- the plan
- the produced effects
- the revalidation outcome
- the commit decision

---

# PHASE_3A.2: OUTBOX SHAPE + EFFECT APPLIER INTERFACE

GOAL:
Introduce the apply boundary without implementing behavior.

FOCUS:
Outbox pattern
Pending effects
Explicit apply lifecycle
World mutation boundary

DELIVERABLES:
- [x] OutboxEntry type + schema
- [x] Outbox status model: PENDING | IN_PROGRESS | APPLIED | FAILED
- [x] Commit writes outbox entries with status=PENDING
- [x] EffectApplier interface stub (apply/markApplied/markFailed)
- [x] Tests proving: commit ≠ apply
- [x] Port pipeline + stage tests from node:test to Vitest (new default)

RULE:
Authority is committed at commit.
World mutation happens only at apply.

EXIT_CRITERIA:
You can point to the exact boundary where:
- authority becomes durable
- world mutation begins

---

# PHASE_3A.3: PORT THE SPINE TO XSTATE

GOAL:
Replace hand-rolled control flow with an explicit state machine.

FOCUS:
State transitions
Guards
Actions (writeback)
Visualization / debugability

DELIVERABLES:
- [ ] Ingestion pipeline expressed as an XState machine
- [ ] Stage gates mapped to XState guards (pre-guards/guards preserved)
- [ ] Stage writebacks mapped to actions
- [ ] Same envelope semantics preserved (audit trail intact)
- [ ] Weekly reflection still runs end-to-end

LEARNING_SIGNAL:
See what a state-machine engine gives you "for free"
and what invariants remain your responsibility.

EXIT_CRITERIA:
You can explain:
- what XState abstracts
- what it does not abstract
- how your contracts stay enforceable

---

# PHASE_3A.4: PORT XSTATE SPINE TO TEMPORAL

GOAL:
Upgrade orchestration to production-grade durability and retries.

FOCUS:
Deterministic workflows
Activities (execution/apply)
Replay semantics
Observability + operational tooling

DELIVERABLES:
- [ ] Temporal workflow representing the ingestion spine
- [ ] Execution and Apply modeled as activities
- [ ] Outbox consumption integrated (still explicit)
- [ ] Replay-safe determinism for plan/fingerprints
- [ ] Tests for drift + commit gating remain unchanged in intent

LEARNING_SIGNAL:
Understand durability, retries, and replay constraints
by comparing to the hand-rolled + XState versions.

EXIT_CRITERIA:
You can explain:
- why workflows must be deterministic
- what Temporal adds (durability, retries, timers)
- what remains domain responsibility (authority, trust)

---

# PHASE_3B: TRIGGERS & DERIVATION WORKFLOWS  // OPTION B

GOAL:
Make derivation explicit, auditable, and safe.

FOCUS:
Trigger → Proposal creation
Derivation as a first-class workflow
Drift prevention

DELIVERABLES:
- [ ] Trigger catalog (what can start a proposal)
- [ ] Trigger-to-proposal policy rules
- [ ] Derivation intent definitions (DERIVE_*)
- [ ] Enforcement that DERIVED meaning always comes from a proposal
- [ ] Audit linkage from source → derived artifacts

SCAFFOLDING TOUCHED:
- Event-driven reasoning
- RAG as a derivation source (not authority)
- Retrieval treated as evidence, not truth

EXIT_CRITERIA:
You can explain:
- why derivation is not a pipeline step
- how derived meaning stays honest over time

---

# PHASE_3C: VALIDATION RISK & ESCALATION POLICY  // OPTION C

GOAL:
Formalize how uncertainty reduces power.

FOCUS:
Fail-closed behavior
Escalation rules
Human-in-the-loop boundaries

DELIVERABLES:
- [ ] Validation risk policy contract
- [ ] Explicit escalation triggers
- [ ] Human confirmation semantics
- [ ] Governor-agent enforcement rules

EXIT_CRITERIA:
You can explain exactly:
- when the system must stop
- when it must escalate
- when it is allowed to proceed narrowly

---

# PHASE_4: EXPRESSION — OBSERVABILITY FIRST

GOAL:
Make the system legible before making it powerful.

FOCUS:
Transparency
Explanation
Debuggability

INITIAL_POSTURE:
Expression is READ-ONLY.

DELIVERABLES:
- [ ] Proposal viewer
- [ ] Decision viewer
- [ ] Execution trace viewer
- [ ] Commit history
- [ ] Provenance graphs

SCAFFOLDING TOUCHED:
- System monitoring
- Error analysis
- Explanation quality assessment

EXIT_CRITERIA:
A human understands system state
without reading code or guessing.

---

# PHASE_5: EXTENSIBILITY — THEMES FIRST

GOAL:
Allow extension without authority leakage.

FOCUS:
Theming
Presentation plugins
Non-authoritative extensibility

DELIVERABLES:
- [ ] Theme plugin interface
- [ ] Theme isolation guarantees
- [ ] Proof that themes cannot alter authority
- [ ] Safe rendering hooks

RULE:
Themes may influence presentation only.
Never validation, execution, or commit.

EXIT_CRITERIA:
Third-party extensions cannot corrupt meaning.

---

# PHASE_6: MCP & TOOL INTEGRATION

GOAL:
Integrate AI tools without surrendering control.

FOCUS:
Tool contracts
Failure handling
Latency & cost awareness

DELIVERABLES:
- [ ] MCP server integration
- [ ] Tool calls wrapped as proposals
- [ ] Tool failures modeled explicitly
- [ ] Tool outputs treated as untrusted input

SCAFFOLDING TOUCHED:
- Model selection as configuration, not logic
- Cost and latency tracking hooks
- Tool success / failure metrics

EXIT_CRITERIA:
Tool failures feel boring, not dangerous.

---

# PHASE_7: AGENTIC SYSTEMS

GOAL:
Introduce long-lived reasoning safely.

FOCUS:
Agent roles
Stop conditions
Planning loops

DELIVERABLES:
- [ ] Agent role definitions
- [ ] Agent state machine
- [ ] Planning → execution loop
- [ ] Explicit stop conditions
- [ ] Escalation triggers

SCAFFOLDING TOUCHED:
- Task completion metrics
- Step count and failure classification
- Cost per task tracking

EXIT_CRITERIA:
You trust agents because you know when they stop.

---

# PHASE_8: MULTI-USER & HUMAN ESCALATION

GOAL:
Support multiple users and expert intervention.

FOCUS:
Attribution
Human authority
Expert escalation

DELIVERABLES:
- [ ] Multi-user identity model
- [ ] Escalation routing rules
- [ ] Expert role definitions
- [ ] Human override semantics
- [ ] Auditability across users

EXIT_CRITERIA:
Authority is clear even with humans in the loop.

---

# PHASE_9: TEACHING & ADAPTIVE LEARNING

GOAL:
Teach users how to think, not just what to do.

FOCUS:
Learning transfer
Personalized guidance
Reflection quality

DELIVERABLES:
- [ ] Teaching engine governance
- [ ] Learning signal tracking
- [ ] Adaptive prompting
- [ ] Fundamentals review rotation
- [ ] Explanation quality feedback

SCAFFOLDING TOUCHED:
- Prompt quality metrics
- Refusal rates
- Format compliance tracking

EXIT_CRITERIA:
The system improves how users reason over time.

---

# CONTINUOUS TRACKS

ALWAYS_ON:
- Fundamentals review (morning / night)
- Explanation practice
- System articulation
- Tool awareness: identify which category solves each recurring spine problem

MEASURE_PROGRESS_BY:
- clarity under pressure
- safe modification ability
- comfort with ambiguity
- ability to name what orchestration tools abstract away

---

# WHERE WE ARE

You are here: **PHASE_3A.2 — Outbox + Apply boundary (COMPLETE)**.

What’s locked in now:
- Stages refactored to fp-ts with consistent error/wrapping patterns
- Unit tests colocated and passing per stage (now running in Vitest)
- E2E spine test(s) running end-to-end (weekly reflection) and validating invariants
- OutboxEntry schema defined and validated
- Commit stage emits deterministic outbox entries (PENDING)
- Tests prove commit ≠ apply

---

After that:
- If you want better orchestration ergonomics/debugging: **PHASE_3A.3 (XState)**
- If you want durability/replay semantics + real retries: **PHASE_3A.4 (Temporal)**

# WHAT’S NEXT

Next milestone: **PHASE_3A.3 — Port the spine to XState**

Immediate next steps:
1. Express the ingestion spine as an XState machine (states = stages).
2. Map pre-guards/guards to XState guards (preserve fail-closed semantics).
3. Map stage writebacks to XState actions (preserve envelope + audit trail).

After that:
- **PHASE_3A.4 (Temporal)** — durability/replay semantics + real retries (activities for execution/apply)